C Copyright 2007 the Regents of the University of California.
C All rights reserved.
C
C***BEGIN PROLOGUE  vanDerPol_AD
C***REFER TO  DDASPK
C***DATE WRITTEN   070226   (YYMMDD)
C
C***AUTHORS  Stephanie R. Taylor
C            University of California
C            Santa Barbara, CA  93106, USA
C
C            L. R. Petzold
C            University of California
C            Santa Barbara, CA  93106, USA
C
C***DESCRIPTION
C
C-----------------------------------------------------------------------
C Example program for DASPK_ADJOINT.
C 2-state ODE system demonstrating limit cycle behavior.
C This example is designed not to perform parametric sensitivity
C analysis, but to retrieve the adjoint variable. Here, we are
C implementing the code to compute the state impulse phase
C response curve (sIPRC) as described in 
C (S.R. Taylor, R. Gunawan, F.J. Doyle III, L.R. Petzold, IEEE TAC, submitted).
C This response curve is used to study a limit cycle oscillator - 
C it predicts the change in phase due to a perturbation in as 
C state value (i.e. will the oscillator jump ahead or behind in its 
C periodic orbit?).
C-----------------------------------------------------------------------
C
C alpha = 1.0D0
C omega = 1.0D0
C dydt(1) = y(2)
C dydt(2) = -alpha*(y(1)**2-1)*y(2) - omega**2*y(1)
C
C The ODE system is solved by DDASPK direct dense method for the linear 
C systems (internal Jacobian)
C
C-----------------------------------------------------------------------
C***END PROLOGUE  vanDerPol_AD
C
      IMPLICIT NONE
      EXTERNAL VDP_RES, JAC, QRES, ADJAC, RES_ADY, ADINIT
      DOUBLE PRECISION ATOL, RTOL, ATOLB, RTOLB
      DOUBLE PRECISION T, DT, TOUT, TFINAL
      DOUBLE PRECISION Y, YPRIME, RPAR, QSEN
      DOUBLE PRECISION RWORK, SENPAR
      DOUBLE PRECISION ADY, ADYP
      INTEGER INFO, INFOBI, IEOPT, IPAR, IDID, IWORK
      INTEGER NY, NEQ, NQ, NEQAD
      INTEGER LIWF, LIWB, LIW, LRWF, LRWB, LRW, NBUF
      INTEGER I, J, K, NUMSTEPS, LQSEN
C     Dimension solution arrays and work arrays.
      PARAMETER (NY=2)
      PARAMETER (NEQ=NY,NQ=NY,NEQAD=NQ*NEQ)
      PARAMETER (LQSEN=NQ*(NEQ+1))
      PARAMETER (NBUF=4*13*NEQ) ! allows 4 checkpoints in memory at the same time
      PARAMETER (LRWF=50 + 9*NEQ + NY*NY)
      PARAMETER (LRWB=50 + 9*NEQAD + NY*NY + 6*NY)
      PARAMETER (LRW=LRWF + LRWB + NBUF + 2*NEQAD + 1 + 2*NEQ + 10)
      PARAMETER (LIWF=40 + NY)
      PARAMETER (LIWB=40 + NEQAD)
      PARAMETER (LIW=LIWF + LIWB + 18 + 2*NEQ + 90)
      DOUBLE PRECISION DUMMY, PSOL
      DIMENSION Y(NY)
      DIMENSION RWORK(LRW)
      DIMENSION IWORK(LIW)
      DIMENSION YPRIME(NEQ)
*     QSEN must be of length NQ*(NEQ+1) (when there are no sensitivity params)
      DIMENSION QSEN(LQSEN)
      DIMENSION INFO(30)
      DIMENSION INFOBI(10)
      DIMENSION IEOPT(2*NEQ)
      DIMENSION RPAR(2)
      DIMENSION IPAR(2)
      DIMENSION RTOL(NEQ), RTOLB(NEQAD)
      DIMENSION ATOL(NEQ), ATOLB(NEQAD)
      DIMENSION ADY(NEQAD), ADYP(NEQAD)
      INTEGER TOTI, LRWORKB, LIWORKB, LICONT
      DOUBLE PRECISION F(NEQ)
C Note that for sensitivity analysis, NY=2, NPARM=INFO(19)
C is the number of problem parameters, NEQ is the total number of
C equations, including sensitivity equations.
C
C     NEQAD is set such that
C                   IF INFOBI(4) .EQ. 0 .AND. INFO(22) .GT> 0 THEN
C                      NEQAD = NQ * (NEQ + INFO(22))
C                   ELSE
C                      NEQAD = NQ * NEQ
C                   END IF
C     where NQ is the number of derived functions, and NEQ is the number
C     of state variables.
c
c===================set-up for adjoint method===========================      
*
* Initialize the INFO AND IEOPT vectors.
*
      DO I = 1, 30
        INFO(I) = 0
      END DO

      DO I = 1, 10
        INFOBI(I) = 0
      END DO

      DO I = 1, 4
        IEOPT(I) = 1
      END DO

*
      T      = 0.D0
      DT     = 1.0000000000d-001
      TFINAL = 2.0000000000d+002
      TOUT   = TFINAL
      NUMSTEPS = 2000
      call init(t,y,yprime,ipar,rpar,neq)

* We are going to use the Jacobian generated by tapenade
      INFO(5) = 1
* We are going retrieve Y,YPRIME,ADY,ADYPRIME at each TOUT
      INFO(3) = 2
* We are going to use a user-supplied QRES
      INFO(20) = 2
* We need to set the flag saying how many derived functions there are
      INFO(24) = NQ
* We are going to supply one tolerance val per entry in Y
      INFO(2)  = 1
      PRINT *, ' Use user-supplied ADINIT? (0=no,3=yes) '
      READ(*,*) INFOBI(2)
* Set RTOL values. 
*
      DO J = 1,NEQ
        RTOL(J) = 1.0000000000d-006
        DO I = 1, NQ
          RTOLB((I-1)*NEQ+J) = 2*1.0000000000d-006
        END DO
      END DO
      ATOL(1) = 1.0000000000d-006
      ATOL(2) = 1.0000000000d-006
      DO I = 1, NQ
        DO J = 1, NEQ
          ATOLB((I-1)*NEQ+J) = 2*ATOL(J)
        END DO
      END DO
C      
c=======================================================================
c
c Call DASPK_Adjoint
c
      TOUT = DT
      DO I = 1, NUMSTEPS + 1
        TOUT = DT * DBLE(NUMSTEPS-I+1)
        IF (TOUT .gt. TFINAL) THEN
          TOUT = TFINAL
        END IF
        IF (TOUT < 0) THEN
          TOUT = 0
        END IF

        CALL DDASPKadjoint(
     1     VDP_RES, NY, T, Y, YPRIME, TOUT, TFINAL, INFO, RTOL, ATOL,
     1     IDID, RWORK, LRW, IWORK, LIW, RPAR, IPAR, JAC,
     1     DUMMY,SENPAR,
     1     DUMMY, NQ, QRES, QSEN, INFOBI, RTOLB, ATOLB, NBUF,
     1     ADJAC, IEOPT, DUMMY, RES_ADY, NEQAD, ADY, ADYP,
     1     DUMMY, DUMMY, ADINIT)
     
        IF (I .EQ. 1) THEN
          CALL VDP_FCN(T,Y,YPRIME,F,RPAR)
        END IF

        IF (idid .lt. 0) GOTO 300
        
C       Write out the state variables
        WRITE (11, *), T, (Y(J),J=1,2)
C       Write out the state impulse phase response curve
C       (computed with respect to Y1)
        WRITE (12, *), T, ADY(1)/F(1), ADY(2)/F(1)
C       Write out the state impulse phase response curve
C       (computed with respect to Y2). Fort.12 and fort.13
C       should contain the same information (allowing for
C       round-off errors due to different methods of 
C       computation, and excluding the transient).
        WRITE (13, *), T, ADY(3)/F(2), ADY(4)/F(2)
      END DO

      write(*,*)
      write(*,*) 'Performance statistics:'
!       write(*,*) ' Time it took:', tt(1)+tt(2)
      TOTI  = IWORK(18) ! length of first chunk of RWORK (RWORKF)
      LICONT  = IWORK(39)
      LIWORKB = IWORK(LICONT+1)
      LRWORKB = IWORK(40)
      IF (LRWORKB.NE.1) THEN
        TOTI = TOTI + IWORK(LIWORKB+18) ! length of RWORKB
      END IF
      TOTI = TOTI + LRW - IWORK(LICONT+18) + 1 ! length of buffer
      print *, ' RWORK size = ', TOTI
      print *, ' length of RWORKF ', IWORK(18)
      print *, 'length of RWORKB ', IWORK(LIWORKB+18)
      print *, ' Buffer size = ', (LRW - IWORK(LICONT+18) + 1), LRW
      TOTI = IWORK(17) ! length of first section of IWORK (IWORKF)
      TOTI = TOTI + 90 ! length of ICONT
      IF (LIWORKB .NE. 1) THEN
        TOTI = TOTI + IWORK(LIWORKB+17) ! len of IWORKB
      END IF
      print *, ' IWORK size = ', TOTI
      print *, ' The values for the two derived functions (q1 = q2):'
      print *, '        ', (qsen(i), i = 1, NQ)

 300  continue
      RETURN
      END
C------  End of main program for van der Pol example program ------------------
*--------------------------------------------------------------------------*
      SUBROUTINE JAC(T,Y,YPRIME_IGNORE,PD,CJ,RPAR,IP,SENPAR,IJAC)
      IMPLICIT NONE
      DOUBLE PRECISION T,Y,YPRIME,YPRIME_IGNORE,PD,CJ,RPAR,SENPAR
      DOUBLE PRECISION PDCOL, YDEP, YDEPD, IGNORE
      INTEGER I,IP,IJAC
      DIMENSION Y(*), YPRIME_IGNORE(*), RPAR(*), SENPAR(*)
      DIMENSION PD(2,*), PDCOL(2), IGNORE(2)
      DIMENSION YPRIME(2)

        DO I = 1, 2
        END DO
        DO I = 1, 2
          YPRIME(I) = 1.0d0
        END DO
*     PD(I,J) = -dF(I)/dY(J) + CJ eye(I,J)
        YDEP = Y(1)
        YDEPD = YPRIME(1)
        CALL VDP_FCN_Y1_D(T,Y,YPRIME,YDEP,YDEPD,IGNORE,PDCOL,RPAR)
        DO I = 1, 2
          PD(I,1) = -PDCOL(I)
        END DO
        PD(1,1) = PD(1,1) + CJ

        YDEP = Y(2)
        YDEPD = YPRIME(2)
        CALL VDP_FCN_Y2_D(T,Y,YPRIME,YDEP,YDEPD,IGNORE,PDCOL,RPAR)
        DO I = 1, 2
          PD(I,2) = -PDCOL(I)
        END DO
        PD(2,2) = PD(2,2) + CJ

      RETURN
      END ! SUBROUTINE JAC
*--------------------------------------------------------------------------*
      SUBROUTINE ADJAC(T,Y,YPRIME_IGNORE,PD,CJ,RPAR,IP,SENPAR,IJAC)
      IMPLICIT NONE
      DOUBLE PRECISION T,Y,YPRIME,YPRIME_IGNORE,PD,CJ,RPAR,SENPAR
      DOUBLE PRECISION PDCOL, YDEP, YDEPD, IGNORE
      INTEGER I,IP,IJAC
      DIMENSION Y(*), YPRIME_IGNORE(*), RPAR(*), SENPAR(*)
      DIMENSION PD(2,*), PDCOL(2), IGNORE(2)
      DIMENSION YPRIME(2)

        DO I = 1, 2
        END DO
        DO I = 1, 2
          YPRIME(I) = 1.0d0
        END DO
*     For regular Jacobian, PD(I,J) = -df(I)/dY(J) + CJ eye(I,J)
*     But we are returning the transpose in this case.
        YDEP = Y(1)
        YDEPD = YPRIME(1)
        CALL VDP_FCN_Y1_D(T,Y,YPRIME,YDEP,YDEPD,IGNORE,PDCOL,RPAR)
        DO I = 1, 2
          PD(1,I) = -PDCOL(I)
        END DO
        PD(1,1) = PD(1,1) + CJ

        YDEP = Y(2)
        YDEPD = YPRIME(2)
        CALL VDP_FCN_Y2_D(T,Y,YPRIME,YDEP,YDEPD,IGNORE,PDCOL,RPAR)
        DO I = 1, 2
          PD(2,I) = -PDCOL(I)
        END DO
        PD(2,2) = PD(2,2) + CJ

      RETURN
      END ! SUBROUTINE ADJAC
*--------------------------------------------------------------------------*
      SUBROUTINE INIT(T,Y,YP,IP,RP,NEQ)
      IMPLICIT NONE
      DOUBLE PRECISION PI, T
      PARAMETER (PI=3.14159265358979323846)
      DOUBLE PRECISION alpha
      DOUBLE PRECISION omega
      DOUBLE PRECISION Y, YP, RP
      INTEGER IP, NEQ, ICTR
      DOUBLE PRECISION RESULT
      DIMENSION Y(*),YP(*),RP(*),IP(*)
      DIMENSION RESULT(2)
*
*
* Place parameter values in RP.
*
      alpha = 1.0000000000d+000
      omega = 1.0000000000d+000
      RP(1) = alpha
      RP(2) = omega

      DO ICTR = 1, 2
      IP(ICTR) = ICTR
      END DO

      DO ICTR = 1,NEQ
      YP(ICTR) = 0.0d0
      Y(ICTR)  = 0.0d0
      END DO

      Y( 1) = 9.3930417174d-001
      Y( 2) = 2.6659352105d+000

      CALL VDP_FCN(T,Y,YP,RESULT,RP)
      YP(1) = RESULT(1)
      YP(2) = RESULT(2)
      RETURN
      END
*--------------------------------------------------------------------------*
      SUBROUTINE QRES(T, Y, YPRIME, Q, IRES, RP, IPAR, SENPAR)
C          If INFO(20) = 2 (user-input is selected), QRES defines
C             both QSEN and the gradients of QSEN with respect
C             to Y and p.
C             The first NQ elements contain the values of g.
C             The elements from NQ+1 to NQ*(NEQ+1) contain the gradient
C                of g with respect to Y. The derivative of the ith function
C                with respect to the jth element in Y is stored at
C                NQ + (j-1)*NQ + i.
C             The elements from NQ*(NEQ+1)+1 to NQ*(NEQ+1+INFO(22)) 
C                contain the gradient of g with respect to p. The 
C                derivative of the ith function with respect to the jth 
C                element in p is stored at NQ*(NEQ+1) + (j-1)*NQ + i.
      IMPLICIT NONE
      DOUBLE PRECISION T, Y, YPRIME, Q, RP, SENPAR
      INTEGER I, J, IPAR, IRES, NEQ, NQ
      PARAMETER (NEQ=2,NQ=2)
      DIMENSION Y(*),YPRIME(*),Q(*),RP(*),SENPAR(*)
      DO I = 1, NQ
        Q(I) = Y(I)
        DO J = 1, NEQ
          IF (I .EQ. J) THEN
            Q(NQ + (J-1)*NQ + I) = 1.0D0
          ELSE
            Q(NQ + (J-1)*NQ + I) = 0.0D0
          END IF
        END DO
      END DO
      RETURN
      END
*--------------------------------------------------------------------------*
      SUBROUTINE ADINIT(T, NEQAD, NQ, Y, YPRIME, ADY, ADYPRIME,
     *             QSEN, RPAR, IPAR, SENPAR)
      IMPLICIT NONE
      DOUBLE PRECISION T, Y(*), YPRIME(*), ADY(*), ADYPRIME(*)
      DOUBLE PRECISION QSEN(*), RPAR(*), SENPAR(*)
      INTEGER          NEQAD, NQ, IPAR(*), NEQ, I, J
      NEQ = NEQAD/NQ
      DO I = 1, NQ
        DO J = 1, NEQ
          ADY((I-1)*NEQ + J) = QSEN(J*NQ + I)
        END DO
      END DO
      DO I = 1, NEQAD
        ADYPRIME(I) = 0.0D0
      END DO
      RETURN
      END
*--------------------------------------------------------------------------*
      SUBROUTINE RES_ADY(T, Y, ADY, YPRIME, CJ, DELTA, ADDELTA,
     *        IRES, RP, IPAR, SENPAR)
      IMPLICIT NONE
      DOUBLE PRECISION T, Y, ADY, YPRIME, DELTA, RP, ADDELTA
      DOUBLE PRECISION SENPAR,CJ
      INTEGER I,IP,IPAR,IRES,IJAC,NEQ
      PARAMETER (NEQ=2)
      DIMENSION ADY(*),YPRIME(*),DELTA(*),Y(*),RP(*),ADDELTA(*)
      DOUBLE PRECISION DELTAB(NEQ), ADY_SAV(NEQ)
C      Computes ADY = ADDELTA * F_y
C      Since ADY is just a vector, we could alternatively write the code
C         ADY = (F_y)^T * ADDELTA
      IJAC = 1
      DO I = 1, NEQ
        DELTAB(I) = ADDELTA(I)
        ADY_SAV(I) = ADY(I)
      END DO
      CALL VDP_RES_B(t, y, ady, yprime, cj, delta, deltab, ires, rp, ip,
     +                 senpar)
      DO I = 1, NEQ
        ADY(I) = ADY(I) + ADY_SAV(I)
      END DO
      RETURN
      END

